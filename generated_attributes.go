package nodx

// Code generated by NodX. DO NOT EDIT.

// Accept specifies the types of files that the server accepts (only for input type='file').
//
//	func ExampleAccept() {
//		node := nodx.Accept("value")
//		fmt.Println(node)
//		// Output: accept="value"
//	}
func Accept(value string) Node {
	return Attr("accept", value)
}

// AcceptCharset specifies the character encodings to be used for form submission.
//
//	func ExampleAcceptCharset() {
//		node := nodx.AcceptCharset("value")
//		fmt.Println(node)
//		// Output: accept-charset="value"
//	}
func AcceptCharset(value string) Node {
	return Attr("accept-charset", value)
}

// Accesskey specifies a shortcut key to activate/focus an element.
//
//	func ExampleAccesskey() {
//		node := nodx.Accesskey("value")
//		fmt.Println(node)
//		// Output: accesskey="value"
//	}
func Accesskey(value string) Node {
	return Attr("accesskey", value)
}

// Action specifies where to send the form-data when a form is submitted.
//
//	func ExampleAction() {
//		node := nodx.Action("value")
//		fmt.Println(node)
//		// Output: action="value"
//	}
func Action(value string) Node {
	return Attr("action", value)
}

// Align specifies the alignment of the element's content.
//
//	func ExampleAlign() {
//		node := nodx.Align("value")
//		fmt.Println(node)
//		// Output: align="value"
//	}
func Align(value string) Node {
	return Attr("align", value)
}

// Allow specifies a feature policy for the iframe.
//
//	func ExampleAllow() {
//		node := nodx.Allow("value")
//		fmt.Println(node)
//		// Output: allow="value"
//	}
func Allow(value string) Node {
	return Attr("allow", value)
}

// Alt provides alternative text for an image if it cannot be displayed.
//
//	func ExampleAlt() {
//		node := nodx.Alt("value")
//		fmt.Println(node)
//		// Output: alt="value"
//	}
func Alt(value string) Node {
	return Attr("alt", value)
}

// Async indicates that the script should be executed asynchronously.
//
//	func ExampleAsync() {
//		node := nodx.Async("value")
//		fmt.Println(node)
//		// Output: async="value"
//	}
func Async(value string) Node {
	return Attr("async", value)
}

// Autocapitalize controls how text input is automatically capitalized.
//
//	func ExampleAutocapitalize() {
//		node := nodx.Autocapitalize("value")
//		fmt.Println(node)
//		// Output: autocapitalize="value"
//	}
func Autocapitalize(value string) Node {
	return Attr("autocapitalize", value)
}

// Autocomplete specifies whether an input field should have autocomplete enabled.
//
//	func ExampleAutocomplete() {
//		node := nodx.Autocomplete("value")
//		fmt.Println(node)
//		// Output: autocomplete="value"
//	}
func Autocomplete(value string) Node {
	return Attr("autocomplete", value)
}

// Autofocus specifies that an input field should automatically get focus when the page loads.
//
//	func ExampleAutofocus() {
//		node := nodx.Autofocus("value")
//		fmt.Println(node)
//		// Output: autofocus="value"
//	}
func Autofocus(value string) Node {
	return Attr("autofocus", value)
}

// Autoplay specifies that the audio/video should start playing as soon as it is ready.
//
//	func ExampleAutoplay() {
//		node := nodx.Autoplay("value")
//		fmt.Println(node)
//		// Output: autoplay="value"
//	}
func Autoplay(value string) Node {
	return Attr("autoplay", value)
}

// Background specifies a background image for the element.
//
//	func ExampleBackground() {
//		node := nodx.Background("value")
//		fmt.Println(node)
//		// Output: background="value"
//	}
func Background(value string) Node {
	return Attr("background", value)
}

// Bgcolor specifies the background color of an element.
//
//	func ExampleBgcolor() {
//		node := nodx.Bgcolor("value")
//		fmt.Println(node)
//		// Output: bgcolor="value"
//	}
func Bgcolor(value string) Node {
	return Attr("bgcolor", value)
}

// Border specifies the border width.
//
//	func ExampleBorder() {
//		node := nodx.Border("value")
//		fmt.Println(node)
//		// Output: border="value"
//	}
func Border(value string) Node {
	return Attr("border", value)
}

// Buffered contains the time ranges that the media element has buffered.
//
//	func ExampleBuffered() {
//		node := nodx.Buffered("value")
//		fmt.Println(node)
//		// Output: buffered="value"
//	}
func Buffered(value string) Node {
	return Attr("buffered", value)
}

// Capture specifies that the camera should be used for input.
//
//	func ExampleCapture() {
//		node := nodx.Capture("value")
//		fmt.Println(node)
//		// Output: capture="value"
//	}
func Capture(value string) Node {
	return Attr("capture", value)
}

// Challenge specifies that the value of the keygen element should be challenged when submitted.
//
//	func ExampleChallenge() {
//		node := nodx.Challenge("value")
//		fmt.Println(node)
//		// Output: challenge="value"
//	}
func Challenge(value string) Node {
	return Attr("challenge", value)
}

// Charset specifies the character encoding.
//
//	func ExampleCharset() {
//		node := nodx.Charset("value")
//		fmt.Println(node)
//		// Output: charset="value"
//	}
func Charset(value string) Node {
	return Attr("charset", value)
}

// Checked specifies that an input element should be pre-selected when the page loads.
//
//	func ExampleChecked() {
//		node := nodx.Checked("value")
//		fmt.Println(node)
//		// Output: checked="value"
//	}
func Checked(value string) Node {
	return Attr("checked", value)
}

// CiteAttr specifies a URL that explains the quote, or why a text was inserted/deleted.
//
//	func ExampleCiteAttr() {
//		node := nodx.CiteAttr("value")
//		fmt.Println(node)
//		// Output: cite="value"
//	}
func CiteAttr(value string) Node {
	return Attr("cite", value)
}

// Class specifies one or more class names for an element.
//
//	func ExampleClass() {
//		node := nodx.Class("value")
//		fmt.Println(node)
//		// Output: class="value"
//	}
func Class(value string) Node {
	return Attr("class", value)
}

// CodeAttr specifies the URL of the applet's class file to be loaded and executed.
//
//	func ExampleCodeAttr() {
//		node := nodx.CodeAttr("value")
//		fmt.Println(node)
//		// Output: code="value"
//	}
func CodeAttr(value string) Node {
	return Attr("code", value)
}

// Codebase specifies the base URL for an applet.
//
//	func ExampleCodebase() {
//		node := nodx.Codebase("value")
//		fmt.Println(node)
//		// Output: codebase="value"
//	}
func Codebase(value string) Node {
	return Attr("codebase", value)
}

// Color specifies the text color of an element.
//
//	func ExampleColor() {
//		node := nodx.Color("value")
//		fmt.Println(node)
//		// Output: color="value"
//	}
func Color(value string) Node {
	return Attr("color", value)
}

// Cols specifies the visible width of a text area.
//
//	func ExampleCols() {
//		node := nodx.Cols("value")
//		fmt.Println(node)
//		// Output: cols="value"
//	}
func Cols(value string) Node {
	return Attr("cols", value)
}

// Colspan specifies the number of columns a cell should span.
//
//	func ExampleColspan() {
//		node := nodx.Colspan("value")
//		fmt.Println(node)
//		// Output: colspan="value"
//	}
func Colspan(value string) Node {
	return Attr("colspan", value)
}

// Content gives the value associated with the http-equiv or name attribute.
//
//	func ExampleContent() {
//		node := nodx.Content("value")
//		fmt.Println(node)
//		// Output: content="value"
//	}
func Content(value string) Node {
	return Attr("content", value)
}

// Contenteditable specifies whether the content of an element is editable.
//
//	func ExampleContenteditable() {
//		node := nodx.Contenteditable("value")
//		fmt.Println(node)
//		// Output: contenteditable="value"
//	}
func Contenteditable(value string) Node {
	return Attr("contenteditable", value)
}

// Contextmenu specifies a context menu for an element.
//
//	func ExampleContextmenu() {
//		node := nodx.Contextmenu("value")
//		fmt.Println(node)
//		// Output: contextmenu="value"
//	}
func Contextmenu(value string) Node {
	return Attr("contextmenu", value)
}

// Controls specifies that audio/video controls should be displayed.
//
//	func ExampleControls() {
//		node := nodx.Controls("value")
//		fmt.Println(node)
//		// Output: controls="value"
//	}
func Controls(value string) Node {
	return Attr("controls", value)
}

// Coords specifies the coordinates of an area in an image-map.
//
//	func ExampleCoords() {
//		node := nodx.Coords("value")
//		fmt.Println(node)
//		// Output: coords="value"
//	}
func Coords(value string) Node {
	return Attr("coords", value)
}

// Crossorigin configures the CORS requests for the element's fetched data.
//
//	func ExampleCrossorigin() {
//		node := nodx.Crossorigin("value")
//		fmt.Println(node)
//		// Output: crossorigin="value"
//	}
func Crossorigin(value string) Node {
	return Attr("crossorigin", value)
}

// Csp allows specifying a Content Security Policy for the content in the iframe.
//
//	func ExampleCsp() {
//		node := nodx.Csp("value")
//		fmt.Println(node)
//		// Output: csp="value"
//	}
func Csp(value string) Node {
	return Attr("csp", value)
}

// DataAttr specifies the URL of the resource to be used by the object.
//
//	func ExampleDataAttr() {
//		node := nodx.DataAttr("value")
//		fmt.Println(node)
//		// Output: data="value"
//	}
func DataAttr(value string) Node {
	return Attr("data", value)
}

// Datetime specifies the date and time.
//
//	func ExampleDatetime() {
//		node := nodx.Datetime("value")
//		fmt.Println(node)
//		// Output: datetime="value"
//	}
func Datetime(value string) Node {
	return Attr("datetime", value)
}

// Decoding indicates how the browser should load the image.
//
//	func ExampleDecoding() {
//		node := nodx.Decoding("value")
//		fmt.Println(node)
//		// Output: decoding="value"
//	}
func Decoding(value string) Node {
	return Attr("decoding", value)
}

// Default specifies the default track kind.
//
//	func ExampleDefault() {
//		node := nodx.Default("value")
//		fmt.Println(node)
//		// Output: default="value"
//	}
func Default(value string) Node {
	return Attr("default", value)
}

// Defer specifies that the script is executed when the page has finished parsing.
//
//	func ExampleDefer() {
//		node := nodx.Defer("value")
//		fmt.Println(node)
//		// Output: defer="value"
//	}
func Defer(value string) Node {
	return Attr("defer", value)
}

// DirAttr specifies the text direction for the content.
//
//	func ExampleDirAttr() {
//		node := nodx.DirAttr("value")
//		fmt.Println(node)
//		// Output: dir="value"
//	}
func DirAttr(value string) Node {
	return Attr("dir", value)
}

// Dirname enables the submission of the text directionality of an input field.
//
//	func ExampleDirname() {
//		node := nodx.Dirname("value")
//		fmt.Println(node)
//		// Output: dirname="value"
//	}
func Dirname(value string) Node {
	return Attr("dirname", value)
}

// Disabled specifies that an element should be disabled.
//
//	func ExampleDisabled() {
//		node := nodx.Disabled("value")
//		fmt.Println(node)
//		// Output: disabled="value"
//	}
func Disabled(value string) Node {
	return Attr("disabled", value)
}

// Download specifies that the target will be downloaded when a user clicks on the hyperlink.
//
//	func ExampleDownload() {
//		node := nodx.Download("value")
//		fmt.Println(node)
//		// Output: download="value"
//	}
func Download(value string) Node {
	return Attr("download", value)
}

// Draggable specifies whether an element is draggable or not.
//
//	func ExampleDraggable() {
//		node := nodx.Draggable("value")
//		fmt.Println(node)
//		// Output: draggable="value"
//	}
func Draggable(value string) Node {
	return Attr("draggable", value)
}

// Enctype specifies how the form-data should be encoded when submitting it to the server.
//
//	func ExampleEnctype() {
//		node := nodx.Enctype("value")
//		fmt.Println(node)
//		// Output: enctype="value"
//	}
func Enctype(value string) Node {
	return Attr("enctype", value)
}

// Enterkeyhint specifies what action label to present for the enter key on virtual keyboards.
//
//	func ExampleEnterkeyhint() {
//		node := nodx.Enterkeyhint("value")
//		fmt.Println(node)
//		// Output: enterkeyhint="value"
//	}
func Enterkeyhint(value string) Node {
	return Attr("enterkeyhint", value)
}

// For specifies which form element a label or output element is bound to.
//
//	func ExampleFor() {
//		node := nodx.For("value")
//		fmt.Println(node)
//		// Output: for="value"
//	}
func For(value string) Node {
	return Attr("for", value)
}

// FormAttr specifies the form the element belongs to.
//
//	func ExampleFormAttr() {
//		node := nodx.FormAttr("value")
//		fmt.Println(node)
//		// Output: form="value"
//	}
func FormAttr(value string) Node {
	return Attr("form", value)
}

// Formaction specifies where to send the form-data when a form is submitted (for input and button elements).
//
//	func ExampleFormaction() {
//		node := nodx.Formaction("value")
//		fmt.Println(node)
//		// Output: formaction="value"
//	}
func Formaction(value string) Node {
	return Attr("formaction", value)
}

// Formenctype specifies how form-data should be encoded (for input and button elements).
//
//	func ExampleFormenctype() {
//		node := nodx.Formenctype("value")
//		fmt.Println(node)
//		// Output: formenctype="value"
//	}
func Formenctype(value string) Node {
	return Attr("formenctype", value)
}

// Formmethod defines the HTTP method for sending form-data (for input and button elements).
//
//	func ExampleFormmethod() {
//		node := nodx.Formmethod("value")
//		fmt.Println(node)
//		// Output: formmethod="value"
//	}
func Formmethod(value string) Node {
	return Attr("formmethod", value)
}

// Formnovalidate defines that form elements should not be validated when submitted.
//
//	func ExampleFormnovalidate() {
//		node := nodx.Formnovalidate("value")
//		fmt.Println(node)
//		// Output: formnovalidate="value"
//	}
func Formnovalidate(value string) Node {
	return Attr("formnovalidate", value)
}

// Formtarget specifies where to display the response after submitting the form.
//
//	func ExampleFormtarget() {
//		node := nodx.Formtarget("value")
//		fmt.Println(node)
//		// Output: formtarget="value"
//	}
func Formtarget(value string) Node {
	return Attr("formtarget", value)
}

// Headers specifies one or more header cells a cell is related to.
//
//	func ExampleHeaders() {
//		node := nodx.Headers("value")
//		fmt.Println(node)
//		// Output: headers="value"
//	}
func Headers(value string) Node {
	return Attr("headers", value)
}

// Height specifies the height of the element.
//
//	func ExampleHeight() {
//		node := nodx.Height("value")
//		fmt.Println(node)
//		// Output: height="value"
//	}
func Height(value string) Node {
	return Attr("height", value)
}

// Hidden specifies that an element is not yet, or is no longer, relevant.
//
//	func ExampleHidden() {
//		node := nodx.Hidden("value")
//		fmt.Println(node)
//		// Output: hidden="value"
//	}
func Hidden(value string) Node {
	return Attr("hidden", value)
}

// High specifies the range that is considered to be a high value.
//
//	func ExampleHigh() {
//		node := nodx.High("value")
//		fmt.Println(node)
//		// Output: high="value"
//	}
func High(value string) Node {
	return Attr("high", value)
}

// Href specifies the URL of the page the link goes to.
//
//	func ExampleHref() {
//		node := nodx.Href("value")
//		fmt.Println(node)
//		// Output: href="value"
//	}
func Href(value string) Node {
	return Attr("href", value)
}

// Hreflang specifies the language of the linked document.
//
//	func ExampleHreflang() {
//		node := nodx.Hreflang("value")
//		fmt.Println(node)
//		// Output: hreflang="value"
//	}
func Hreflang(value string) Node {
	return Attr("hreflang", value)
}

// HttpEquiv provides an HTTP header for the information/value of the content attribute.
//
//	func ExampleHttpEquiv() {
//		node := nodx.HttpEquiv("value")
//		fmt.Println(node)
//		// Output: http-equiv="value"
//	}
func HttpEquiv(value string) Node {
	return Attr("http-equiv", value)
}

// Icon specifies an icon for the command.
//
//	func ExampleIcon() {
//		node := nodx.Icon("value")
//		fmt.Println(node)
//		// Output: icon="value"
//	}
func Icon(value string) Node {
	return Attr("icon", value)
}

// Id specifies a unique id for an element.
//
//	func ExampleId() {
//		node := nodx.Id("value")
//		fmt.Println(node)
//		// Output: id="value"
//	}
func Id(value string) Node {
	return Attr("id", value)
}

// Importance indicates the relative fetch priority for the resource.
//
//	func ExampleImportance() {
//		node := nodx.Importance("value")
//		fmt.Println(node)
//		// Output: importance="value"
//	}
func Importance(value string) Node {
	return Attr("importance", value)
}

// Integrity allows a browser to verify the fetched resource's integrity.
//
//	func ExampleIntegrity() {
//		node := nodx.Integrity("value")
//		fmt.Println(node)
//		// Output: integrity="value"
//	}
func Integrity(value string) Node {
	return Attr("integrity", value)
}

// Ismap specifies an image as a server-side image-map.
//
//	func ExampleIsmap() {
//		node := nodx.Ismap("value")
//		fmt.Println(node)
//		// Output: ismap="value"
//	}
func Ismap(value string) Node {
	return Attr("ismap", value)
}

// Itemprop defines a property of an item.
//
//	func ExampleItemprop() {
//		node := nodx.Itemprop("value")
//		fmt.Println(node)
//		// Output: itemprop="value"
//	}
func Itemprop(value string) Node {
	return Attr("itemprop", value)
}

// Keytype specifies the security algorithm of a key.
//
//	func ExampleKeytype() {
//		node := nodx.Keytype("value")
//		fmt.Println(node)
//		// Output: keytype="value"
//	}
func Keytype(value string) Node {
	return Attr("keytype", value)
}

// Kind specifies the kind of text track.
//
//	func ExampleKind() {
//		node := nodx.Kind("value")
//		fmt.Println(node)
//		// Output: kind="value"
//	}
func Kind(value string) Node {
	return Attr("kind", value)
}

// LabelAttr specifies the title of the text track.
//
//	func ExampleLabelAttr() {
//		node := nodx.LabelAttr("value")
//		fmt.Println(node)
//		// Output: label="value"
//	}
func LabelAttr(value string) Node {
	return Attr("label", value)
}

// Lang specifies the language of the element's content.
//
//	func ExampleLang() {
//		node := nodx.Lang("value")
//		fmt.Println(node)
//		// Output: lang="value"
//	}
func Lang(value string) Node {
	return Attr("lang", value)
}

// Language deprecated. Specifies the scripting language used for the script.
//
//	func ExampleLanguage() {
//		node := nodx.Language("value")
//		fmt.Println(node)
//		// Output: language="value"
//	}
func Language(value string) Node {
	return Attr("language", value)
}

// Loading indicates how the browser should load the image or iframe.
//
//	func ExampleLoading() {
//		node := nodx.Loading("value")
//		fmt.Println(node)
//		// Output: loading="value"
//	}
func Loading(value string) Node {
	return Attr("loading", value)
}

// List refers to a datalist element that contains pre-defined options.
//
//	func ExampleList() {
//		node := nodx.List("value")
//		fmt.Println(node)
//		// Output: list="value"
//	}
func List(value string) Node {
	return Attr("list", value)
}

// Loop specifies that the audio/video will start over again, every time it is finished.
//
//	func ExampleLoop() {
//		node := nodx.Loop("value")
//		fmt.Println(node)
//		// Output: loop="value"
//	}
func Loop(value string) Node {
	return Attr("loop", value)
}

// Low specifies the range that is considered to be a low value.
//
//	func ExampleLow() {
//		node := nodx.Low("value")
//		fmt.Println(node)
//		// Output: low="value"
//	}
func Low(value string) Node {
	return Attr("low", value)
}

// Manifest specifies the URL of the document's cache manifest.
//
//	func ExampleManifest() {
//		node := nodx.Manifest("value")
//		fmt.Println(node)
//		// Output: manifest="value"
//	}
func Manifest(value string) Node {
	return Attr("manifest", value)
}

// Max specifies the maximum value.
//
//	func ExampleMax() {
//		node := nodx.Max("value")
//		fmt.Println(node)
//		// Output: max="value"
//	}
func Max(value string) Node {
	return Attr("max", value)
}

// Maxlength specifies the maximum number of characters allowed in an input field.
//
//	func ExampleMaxlength() {
//		node := nodx.Maxlength("value")
//		fmt.Println(node)
//		// Output: maxlength="value"
//	}
func Maxlength(value string) Node {
	return Attr("maxlength", value)
}

// Media specifies what media/device the linked document is optimized for.
//
//	func ExampleMedia() {
//		node := nodx.Media("value")
//		fmt.Println(node)
//		// Output: media="value"
//	}
func Media(value string) Node {
	return Attr("media", value)
}

// Method specifies the HTTP method to use when sending form-data.
//
//	func ExampleMethod() {
//		node := nodx.Method("value")
//		fmt.Println(node)
//		// Output: method="value"
//	}
func Method(value string) Node {
	return Attr("method", value)
}

// Min specifies the minimum value.
//
//	func ExampleMin() {
//		node := nodx.Min("value")
//		fmt.Println(node)
//		// Output: min="value"
//	}
func Min(value string) Node {
	return Attr("min", value)
}

// Minlength specifies the minimum number of characters required in an input field.
//
//	func ExampleMinlength() {
//		node := nodx.Minlength("value")
//		fmt.Println(node)
//		// Output: minlength="value"
//	}
func Minlength(value string) Node {
	return Attr("minlength", value)
}

// Multiple specifies that a user can enter more than one value.
//
//	func ExampleMultiple() {
//		node := nodx.Multiple("value")
//		fmt.Println(node)
//		// Output: multiple="value"
//	}
func Multiple(value string) Node {
	return Attr("multiple", value)
}

// Muted specifies that the audio output should be muted.
//
//	func ExampleMuted() {
//		node := nodx.Muted("value")
//		fmt.Println(node)
//		// Output: muted="value"
//	}
func Muted(value string) Node {
	return Attr("muted", value)
}

// Name specifies the name of the element.
//
//	func ExampleName() {
//		node := nodx.Name("value")
//		fmt.Println(node)
//		// Output: name="value"
//	}
func Name(value string) Node {
	return Attr("name", value)
}

// Nomodule indicates that the script should not be executed in browsers that support module scripts.
//
//	func ExampleNomodule() {
//		node := nodx.Nomodule("value")
//		fmt.Println(node)
//		// Output: nomodule="value"
//	}
func Nomodule(value string) Node {
	return Attr("nomodule", value)
}

// Nonce a cryptographic nonce used in Content Security Policy.
//
//	func ExampleNonce() {
//		node := nodx.Nonce("value")
//		fmt.Println(node)
//		// Output: nonce="value"
//	}
func Nonce(value string) Node {
	return Attr("nonce", value)
}

// Novalidate specifies that the form should not be validated when submitted.
//
//	func ExampleNovalidate() {
//		node := nodx.Novalidate("value")
//		fmt.Println(node)
//		// Output: novalidate="value"
//	}
func Novalidate(value string) Node {
	return Attr("novalidate", value)
}

// Open specifies that the details should be visible to the user.
//
//	func ExampleOpen() {
//		node := nodx.Open("value")
//		fmt.Println(node)
//		// Output: open="value"
//	}
func Open(value string) Node {
	return Attr("open", value)
}

// Optimum specifies the optimal value of the gauge.
//
//	func ExampleOptimum() {
//		node := nodx.Optimum("value")
//		fmt.Println(node)
//		// Output: optimum="value"
//	}
func Optimum(value string) Node {
	return Attr("optimum", value)
}

// Pattern specifies a regular expression that the input element's value is checked against.
//
//	func ExamplePattern() {
//		node := nodx.Pattern("value")
//		fmt.Println(node)
//		// Output: pattern="value"
//	}
func Pattern(value string) Node {
	return Attr("pattern", value)
}

// Ping specifies a space-separated list of URLs to be notified if a user follows the hyperlink.
//
//	func ExamplePing() {
//		node := nodx.Ping("value")
//		fmt.Println(node)
//		// Output: ping="value"
//	}
func Ping(value string) Node {
	return Attr("ping", value)
}

// Placeholder specifies a short hint that describes the expected value of an input field.
//
//	func ExamplePlaceholder() {
//		node := nodx.Placeholder("value")
//		fmt.Println(node)
//		// Output: placeholder="value"
//	}
func Placeholder(value string) Node {
	return Attr("placeholder", value)
}

// Playsinline indicates that the video should play inline on mobile devices.
//
//	func ExamplePlaysinline() {
//		node := nodx.Playsinline("value")
//		fmt.Println(node)
//		// Output: playsinline="value"
//	}
func Playsinline(value string) Node {
	return Attr("playsinline", value)
}

// Poster specifies an image to be shown while the video is downloading or until the user hits the play button.
//
//	func ExamplePoster() {
//		node := nodx.Poster("value")
//		fmt.Println(node)
//		// Output: poster="value"
//	}
func Poster(value string) Node {
	return Attr("poster", value)
}

// Preload specifies if and how the author thinks the audio/video should be loaded when the page loads.
//
//	func ExamplePreload() {
//		node := nodx.Preload("value")
//		fmt.Println(node)
//		// Output: preload="value"
//	}
func Preload(value string) Node {
	return Attr("preload", value)
}

// Readonly specifies that the input field is read-only.
//
//	func ExampleReadonly() {
//		node := nodx.Readonly("value")
//		fmt.Println(node)
//		// Output: readonly="value"
//	}
func Readonly(value string) Node {
	return Attr("readonly", value)
}

// Referrerpolicy specifies which referrer information to send when fetching a resource.
//
//	func ExampleReferrerpolicy() {
//		node := nodx.Referrerpolicy("value")
//		fmt.Println(node)
//		// Output: referrerpolicy="value"
//	}
func Referrerpolicy(value string) Node {
	return Attr("referrerpolicy", value)
}

// Rel specifies the relationship between the current document and the linked document.
//
//	func ExampleRel() {
//		node := nodx.Rel("value")
//		fmt.Println(node)
//		// Output: rel="value"
//	}
func Rel(value string) Node {
	return Attr("rel", value)
}

// Required specifies that the input field must be filled out before submitting the form.
//
//	func ExampleRequired() {
//		node := nodx.Required("value")
//		fmt.Println(node)
//		// Output: required="value"
//	}
func Required(value string) Node {
	return Attr("required", value)
}

// Reversed specifies that the list order should be descending (9,8,7...).
//
//	func ExampleReversed() {
//		node := nodx.Reversed("value")
//		fmt.Println(node)
//		// Output: reversed="value"
//	}
func Reversed(value string) Node {
	return Attr("reversed", value)
}

// Rows specifies the visible number of lines in a text area.
//
//	func ExampleRows() {
//		node := nodx.Rows("value")
//		fmt.Println(node)
//		// Output: rows="value"
//	}
func Rows(value string) Node {
	return Attr("rows", value)
}

// Rowspan specifies the number of rows a cell should span.
//
//	func ExampleRowspan() {
//		node := nodx.Rowspan("value")
//		fmt.Println(node)
//		// Output: rowspan="value"
//	}
func Rowspan(value string) Node {
	return Attr("rowspan", value)
}

// Sandbox enables an extra set of restrictions for the content in an iframe.
//
//	func ExampleSandbox() {
//		node := nodx.Sandbox("value")
//		fmt.Println(node)
//		// Output: sandbox="value"
//	}
func Sandbox(value string) Node {
	return Attr("sandbox", value)
}

// Scope specifies whether a header cell is a header for a column, row, or group of columns or rows.
//
//	func ExampleScope() {
//		node := nodx.Scope("value")
//		fmt.Println(node)
//		// Output: scope="value"
//	}
func Scope(value string) Node {
	return Attr("scope", value)
}

// Scoped specifies that the styles only apply to this element's parent and child elements.
//
//	func ExampleScoped() {
//		node := nodx.Scoped("value")
//		fmt.Println(node)
//		// Output: scoped="value"
//	}
func Scoped(value string) Node {
	return Attr("scoped", value)
}

// Selected specifies that an option should be pre-selected when the page loads.
//
//	func ExampleSelected() {
//		node := nodx.Selected("value")
//		fmt.Println(node)
//		// Output: selected="value"
//	}
func Selected(value string) Node {
	return Attr("selected", value)
}

// Shape specifies the shape of an area in an image-map.
//
//	func ExampleShape() {
//		node := nodx.Shape("value")
//		fmt.Println(node)
//		// Output: shape="value"
//	}
func Shape(value string) Node {
	return Attr("shape", value)
}

// Size specifies the width, in characters, of an input field.
//
//	func ExampleSize() {
//		node := nodx.Size("value")
//		fmt.Println(node)
//		// Output: size="value"
//	}
func Size(value string) Node {
	return Attr("size", value)
}

// Sizes specifies the sizes of icons for visual media.
//
//	func ExampleSizes() {
//		node := nodx.Sizes("value")
//		fmt.Println(node)
//		// Output: sizes="value"
//	}
func Sizes(value string) Node {
	return Attr("sizes", value)
}

// SlotAttr assigns a slot in a shadow DOM shadow tree.
//
//	func ExampleSlotAttr() {
//		node := nodx.SlotAttr("value")
//		fmt.Println(node)
//		// Output: slot="value"
//	}
func SlotAttr(value string) Node {
	return Attr("slot", value)
}

// SpanAttr defines the number of columns to span for a col or colgroup element.
//
//	func ExampleSpanAttr() {
//		node := nodx.SpanAttr("value")
//		fmt.Println(node)
//		// Output: span="value"
//	}
func SpanAttr(value string) Node {
	return Attr("span", value)
}

// Spellcheck specifies whether the element is to have its spelling and grammar checked or not.
//
//	func ExampleSpellcheck() {
//		node := nodx.Spellcheck("value")
//		fmt.Println(node)
//		// Output: spellcheck="value"
//	}
func Spellcheck(value string) Node {
	return Attr("spellcheck", value)
}

// Src specifies the URL of the media file.
//
//	func ExampleSrc() {
//		node := nodx.Src("value")
//		fmt.Println(node)
//		// Output: src="value"
//	}
func Src(value string) Node {
	return Attr("src", value)
}

// Srcdoc specifies the HTML content of the page to show in the iframe.
//
//	func ExampleSrcdoc() {
//		node := nodx.Srcdoc("value")
//		fmt.Println(node)
//		// Output: srcdoc="value"
//	}
func Srcdoc(value string) Node {
	return Attr("srcdoc", value)
}

// Srclang specifies the language of the track text data (required if kind='subtitles').
//
//	func ExampleSrclang() {
//		node := nodx.Srclang("value")
//		fmt.Println(node)
//		// Output: srclang="value"
//	}
func Srclang(value string) Node {
	return Attr("srclang", value)
}

// Srcset specifies the URL of the image to use in different situations.
//
//	func ExampleSrcset() {
//		node := nodx.Srcset("value")
//		fmt.Println(node)
//		// Output: srcset="value"
//	}
func Srcset(value string) Node {
	return Attr("srcset", value)
}

// Start specifies the start value of an ordered list.
//
//	func ExampleStart() {
//		node := nodx.Start("value")
//		fmt.Println(node)
//		// Output: start="value"
//	}
func Start(value string) Node {
	return Attr("start", value)
}

// Step specifies the legal number intervals for an input field.
//
//	func ExampleStep() {
//		node := nodx.Step("value")
//		fmt.Println(node)
//		// Output: step="value"
//	}
func Step(value string) Node {
	return Attr("step", value)
}

// StyleAttr specifies an inline CSS style for an element.
//
//	func ExampleStyleAttr() {
//		node := nodx.StyleAttr("value")
//		fmt.Println(node)
//		// Output: style="value"
//	}
func StyleAttr(value string) Node {
	return Attr("style", value)
}

// SummaryAttr specifies a summary of the content of a table (deprecated in HTML5).
//
//	func ExampleSummaryAttr() {
//		node := nodx.SummaryAttr("value")
//		fmt.Println(node)
//		// Output: summary="value"
//	}
func SummaryAttr(value string) Node {
	return Attr("summary", value)
}

// Tabindex specifies the tabbing order of an element.
//
//	func ExampleTabindex() {
//		node := nodx.Tabindex("value")
//		fmt.Println(node)
//		// Output: tabindex="value"
//	}
func Tabindex(value string) Node {
	return Attr("tabindex", value)
}

// Target specifies where to open the linked document.
//
//	func ExampleTarget() {
//		node := nodx.Target("value")
//		fmt.Println(node)
//		// Output: target="value"
//	}
func Target(value string) Node {
	return Attr("target", value)
}

// TitleAttr specifies extra information about an element.
//
//	func ExampleTitleAttr() {
//		node := nodx.TitleAttr("value")
//		fmt.Println(node)
//		// Output: title="value"
//	}
func TitleAttr(value string) Node {
	return Attr("title", value)
}

// Translate specifies whether the content of an element should be translated or not.
//
//	func ExampleTranslate() {
//		node := nodx.Translate("value")
//		fmt.Println(node)
//		// Output: translate="value"
//	}
func Translate(value string) Node {
	return Attr("translate", value)
}

// Type specifies the type of element.
//
//	func ExampleType() {
//		node := nodx.Type("value")
//		fmt.Println(node)
//		// Output: type="value"
//	}
func Type(value string) Node {
	return Attr("type", value)
}

// Usemap specifies an image as a client-side image-map.
//
//	func ExampleUsemap() {
//		node := nodx.Usemap("value")
//		fmt.Println(node)
//		// Output: usemap="value"
//	}
func Usemap(value string) Node {
	return Attr("usemap", value)
}

// Value specifies the value of the element.
//
//	func ExampleValue() {
//		node := nodx.Value("value")
//		fmt.Println(node)
//		// Output: value="value"
//	}
func Value(value string) Node {
	return Attr("value", value)
}

// Width specifies the width of the element.
//
//	func ExampleWidth() {
//		node := nodx.Width("value")
//		fmt.Println(node)
//		// Output: width="value"
//	}
func Width(value string) Node {
	return Attr("width", value)
}

// Wrap specifies how the text in a text area is to be wrapped when submitted in a form.
//
//	func ExampleWrap() {
//		node := nodx.Wrap("value")
//		fmt.Println(node)
//		// Output: wrap="value"
//	}
func Wrap(value string) Node {
	return Attr("wrap", value)
}

// Aria defines accessibility semantics or aria properties.
//
//	func ExampleAria() {
//		node := nodx.Aria("key", "value")
//		fmt.Println(node)
//		// Output: aria-key="value"
//	}
func Aria(key string, value string) Node {
	return Attr("aria-"+key, value)
}

// Data used to store custom data private to the page or application.
//
//	func ExampleData() {
//		node := nodx.Data("key", "value")
//		fmt.Println(node)
//		// Output: data-key="value"
//	}
func Data(key string, value string) Node {
	return Attr("data-"+key, value)
}

// Role defines the role of an element for accessibility purposes.
//
//	func ExampleRole() {
//		node := nodx.Role("value")
//		fmt.Println(node)
//		// Output: role="value"
//	}
func Role(value string) Node {
	return Attr("role", value)
}
